import { joinPathFragments, Tree } from '@nx/devkit';
import { createTreeWithEmptyWorkspace } from '@nx/devkit/testing';
import { extractPrimitiveCodeGenerator } from './generator';

describe('extractPrimitiveCodeGenerator', () => {
	let tree: Tree;
	const componentsBasePath = 'apps/app/src/app/pages/(components)/components';

	beforeEach(() => {
		tree = createTreeWithEmptyWorkspace();
	});

	function createMockPreviewFile(primitiveName: string, content: string): string {
		const filePath = joinPathFragments(componentsBasePath, primitiveName, `${primitiveName}.preview.ts`);
		tree.write(filePath, content);
		return filePath;
	}

	function createMockExampleFile(primitiveName: string, exampleName: string, content: string): string {
		const filePath = joinPathFragments(componentsBasePath, primitiveName, `${exampleName}.example.ts`);
		tree.write(filePath, content);
		return filePath;
	}

	function getGeneratedFileContent(primitiveName: string): string | null {
		const filePath = joinPathFragments(componentsBasePath, primitiveName, `${primitiveName}.generated.ts`);
		return tree.read(filePath, 'utf-8');
	}

	function expectGeneratedFileExists(primitiveName: string): void {
		const filePath = joinPathFragments(componentsBasePath, primitiveName, `${primitiveName}.generated.ts`);
		expect(tree.exists(filePath)).toBe(true);
	}

	function expectGeneratedFileNotExists(primitiveName: string): void {
		const filePath = joinPathFragments(componentsBasePath, primitiveName, `${primitiveName}.generated.ts`);
		expect(tree.exists(filePath)).toBe(false);
	}

	const mockAngularComponent = `
import { Component } from '@angular/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { lucideBox } from '@ng-icons/lucide';
import { HlmAlertDirective } from '@spartan-ng/helm/alert';

@Component({
  selector: 'spartan-alert-preview',
  imports: [HlmAlertDirective, NgIcon],
  providers: [provideIcons({ lucideBox })],
  template: \`
    <div hlmAlert>
      <ng-icon name="lucideBox" />
      <h4>Test Alert</h4>
    </div>
  \`
})
export class AlertPreviewComponent {}
`;

	const mockComponentWithUnwantedExports = `
import { Component } from '@angular/core';

@Component({
  selector: 'test-component',
  template: '<div>Hello World</div>'
})
export class TestComponent {}

// These should be removed by the generator
export const defaultSkeleton = \`<div>skeleton</div>\`;
export const defaultImports = \`import stuff\`;
export const someOtherCode = \`console.log('test');\`;
export const defaultCode = \`should be removed\`;
`;

	describe('when processing valid preview files', () => {
		it('should generate file with defaultCode export', async () => {
			// Arrange
			createMockPreviewFile('alert', mockAngularComponent);

			// Act
			await extractPrimitiveCodeGenerator(tree);

			// Assert
			expectGeneratedFileExists('alert');

			const content = getGeneratedFileContent('alert');
			expect(content).toContain('export const defaultCode = `');
			expect(content).toContain('AlertPreviewComponent');
			expect(content).toContain('spartan-alert-preview'); // from selector
		});

		it('should include proper header comments', async () => {
			// Arrange
			createMockPreviewFile('button', mockAngularComponent);

			// Act
			await extractPrimitiveCodeGenerator(tree);

			// Assert
			const content = getGeneratedFileContent('button');
			expect(content).toContain('// eslint-disable -- auto-generated');
			expect(content).toContain('// prettier-ignore -- auto-generated');
			expect(content).toContain('DO NOT EDIT THIS FILE!!');
		});

		it('should handle multiple example files', async () => {
			// Arrange
			createMockPreviewFile('toggle', mockAngularComponent);
			createMockExampleFile(
				'toggle',
				'disabled',
				mockAngularComponent.replace('AlertPreviewComponent', 'DisabledComponent'),
			);

			// Act
			await extractPrimitiveCodeGenerator(tree);

			// Assert
			const content = getGeneratedFileContent('toggle');
			expect(content).toContain('export const defaultCode = `');
			expect(content).toContain('export const disabledCode = `'); // from filename
			expect(content).toContain('AlertPreviewComponent'); // from preview
			expect(content).toContain('DisabledComponent'); // from example
		});
	});

	describe('when filtering unwanted exports', () => {
		it('should remove export const with Code suffix', async () => {
			// Arrange
			createMockPreviewFile('test', mockComponentWithUnwantedExports);

			// Act
			await extractPrimitiveCodeGenerator(tree);

			// Assert
			const content = getGeneratedFileContent('test');
			expect(content).toContain('TestComponent'); // Keep the actual component
			expect(content).toContain('someOtherCode'); // Remove other code export
			expect(content).not.toContain('should be removed'); // Remove defaultCode content
			expect(content).not.toContain('defaultSkeleton'); // Remove skeleton export
			expect(content).not.toContain('defaultImports'); // Remove imports export
		});

		it('should preserve import statements and decorators', async () => {
			// Arrange
			const componentWithImports = `
import { Component } from '@angular/core';
import { SomeService } from './service';

@Component({
  selector: 'test-comp',
  template: '<div>Test</div>'
})
export class TestComp {}

export const someNeededConst = \`don't remove me\`;
`;
			createMockPreviewFile('imports', componentWithImports);

			// Act
			await extractPrimitiveCodeGenerator(tree);

			// Assert
			const content = getGeneratedFileContent('imports');
			expect(content).toContain("import { Component } from '@angular/core'");
			expect(content).toContain("import { SomeService } from './service'");
			expect(content).toContain('@Component({');
			expect(content).toContain('someNeededConst');
			expect(content).toContain("don't remove me");
		});
	});

	describe('when handling edge cases', () => {
		it('should handle missing components directory', async () => {
			// Arrange - no components directory created

			// Act & Assert - should not throw
			await expect(extractPrimitiveCodeGenerator(tree)).resolves.not.toThrow();

			// No files should be generated
			expectGeneratedFileNotExists('alert');
		});

		it('should skip primitive with no preview files', async () => {
			// Arrange - create directory but no preview file
			const primitiveDir = joinPathFragments(componentsBasePath, 'empty');
			tree.write(joinPathFragments(primitiveDir, 'some-other-file.ts'), '// not a preview');

			// Act
			await extractPrimitiveCodeGenerator(tree);

			// Assert
			expectGeneratedFileNotExists('empty');
		});

		it('should continue processing other primitives if one fails', async () => {
			// Arrange
			createMockPreviewFile('good', mockAngularComponent);
			// Create a primitive directory but don't create proper files for 'bad'
			tree.write(joinPathFragments(componentsBasePath, 'bad', 'not-preview.ts'), 'invalid');

			// Act
			await extractPrimitiveCodeGenerator(tree);

			// Assert
			expectGeneratedFileExists('good'); // Should still process the good one
			expectGeneratedFileNotExists('bad'); // Should skip the bad one
		});
	});

	describe('when handling primitive name variations', () => {
		it('should handle primitive names with parentheses', async () => {
			// Arrange
			createMockPreviewFile('(special)', mockAngularComponent);

			// Act
			await extractPrimitiveCodeGenerator(tree);

			// Assert
			// Should create file with cleaned name (no parentheses)
			const filePath = joinPathFragments(componentsBasePath, '(special)', 'special.generated.ts');
			expect(tree.exists(filePath)).toBe(true);
		});
	});
});
